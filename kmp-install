#!/usr/bin/perl

use strict;
use warnings;

use File::Find;

sub add_package {
	my ($list, $attr) = @_;

	my $new = {
		name =>    $attr->[0],
		version => $attr->[1],
		arch =>    $attr->[2],
	};
	$new->{repo} = $attr->[3] if defined($attr->[3]);
	# old-version -> new-version
	$new->{version} =~ s/.*->\s*//;
	push(@$list, $new);
}

sub query_installed_kmps {
	my $res = shift;
	my %seen;

	open(my $pipe, '-|', "rpm", "-qa", "--qf", '[%{n} %{v} %{r} %{arch} %{filenames}\n]', "*-kmp-*");
	while (<$pipe>) {
		chomp;
		my ($n, $v, $r, $a, $file) = split(' ');
		next unless $file =~ m@^/lib/modules/.*/.*/.*\.ko$@;
		my $nvra = "$n-$v-$r.$a";
		if (!exists($seen{$nvra})) {
			add_package($res, [$n, "$v-$r", $a]);
			$seen{$nvra} = $res->[$#$res];
			$seen{$nvra}->{files} = [];
		}
		push(@{$seen{$nvra}->{files}}, $file);
	}
}


sub fetch_packages {
	my $interactive = shift;
	my $new_pkgs = shift;
	my $remove_pkgs = shift;

	my @cmd = qw(zypper);
	push(@cmd, "--non-interactive") if !$interactive;
	push(@cmd, qw(-vv install --download-only));
	push(@cmd, @_);
	pipe(READ, WRITE);
	my $pid = fork();
	if (!$pid) {
		# child
		close(READ);
		open(STDOUT, ">&WRITE");
		if (!$interactive) {
			open(NULL, '<', "/dev/null");
			open(STDIN, "<&NULL");
			close(NULL);
			open(NULL, '>', "/dev/null");
			open(STDERR, ">&NULL");
			close(NULL);
		}
		exec(@cmd);
	}
	# parent
	close(WRITE);
	my ($len, $buf, $last_line);
	my ($state, @cur_pkg);
	$state = 0;
	$last_line = "";
	my $list;
	STDOUT->autoflush(1);
	while (($len = sysread(READ, $buf, 4096))) {
		print $buf if $interactive;
		my @lines = split(/\n/, $buf, -1);
		$lines[0] = $last_line . $lines[0];
		# XXX: Assumes that the very last line is terminated by \n
		$last_line = pop(@lines);
		for my $l (@lines) {
			if ($state == 0 && $l =~ /^The following.* package.* going to be (installed|upgraded|REMOVED):/) {
				if ($1 eq "REMOVED") {
					$list = $remove_pkgs;
				} else {
					$list = $new_pkgs;
				}
				$state = 1;
				next;
			}
			next unless $state == 1;
			if ($l eq "") {
				$state = 0;
				if (@cur_pkg) {
					add_package($list, \@cur_pkg);
				}
				@cur_pkg = ();
				next;
			}
			$l =~ s/ *$//;
			if ($l =~ /^[^ ]/) {
				if (@cur_pkg) {
					add_package($list, \@cur_pkg);
				}
				@cur_pkg = ($l);
			}
			if ($l =~ /^ /) {
				$l =~ s/^ *//;
				push(@cur_pkg, $l);
			}
		}
	}
	STDOUT->autoflush(0);
	close(READ);
	waitpid($pid, 0);
	return $?;
}

my %repo_cache;
sub get_repo_cache {
	my $name = shift;
	my $res;

	if (exists($repo_cache{$name})) {
		return $repo_cache{$name};
	}
	open(my $pipe, '-|', "zypper", "repos", $name);
	while (<$pipe>) {
		chomp;
		if (m@^MD Cache Path\s*:\s*(/.*)@) {
			$res = $1;
			$res =~ s:/raw/:/packages/:;
			$res =~ s/\s*$//;
		}
	}
	close($pipe);
	$repo_cache{$name} = $res;
	return $res;
}

print "Fetching packages\n";
my (@new_pkgs, @remove_pkgs);
my $ret = fetch_packages(0, \@new_pkgs, \@remove_pkgs, @ARGV);
if ($ret != 0) {
	print "zypper returned an error, retrying in interactive mode\n";
	@new_pkgs = ();
	@remove_pkgs = ();
	$ret = fetch_packages(1, \@new_pkgs, \@remove_pkgs, @ARGV);
}
if ($ret != 0) {
	exit 1;
}
my %local_packages;
for $a (@ARGV) {
	if ($a =~ /\.rpm$/ && -e $a) {
		open(my $pipe, '-|', "rpm", "-qp", "--qf",
			'%{n}-%{v}-%{r}.%{arch}', $a);
		my $nvra = <$pipe>;
		close($pipe);
		if (defined($nvra)) {
			$local_packages{$nvra} = $a;
		}
	}
}

for my $p (@new_pkgs) {
	my $nvra = "$p->{name}-$p->{version}.$p->{arch}";
	if ($p->{repo} eq "Plain RPM files cache") {
		if (exists($local_packages{$nvra})) {
			$p->{path} = $local_packages{$nvra};
		} else {
			print STDERR "Cannot find package $p->{name}\n";
		}
		next;
	}
	my $dir = get_repo_cache($p->{repo});
	if (!$dir) {
		print STDERR "Cannot find zypper cache for repository $p->{repo} (package $p->{name})\n";
		next;
	}
	my $file = "$nvra.rpm";
	my $wanted = sub {
		$p->{path} = $File::Find::name if $_ eq $file;
	};
	find($wanted, $dir);
	if (!$p->{path}) {
		print STDERR "Cannot find $file in zypper cache ($dir)\n";
		next;
	}
}

my @installed;
query_installed_kmps(\@installed);

for my $p (@new_pkgs) {
	print "$p->{path}\n" if $p->{path};
}
for my $p (@remove_pkgs) {
	print "REMOVE: $p->{name}\n";
}
for my $p (@installed) {
	print "INSTALLED: $p->{name}\n";
}
