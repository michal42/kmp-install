#!/usr/bin/perl

use strict;
use warnings;

use File::Find;

sub add_package {
	my ($list, $attr) = @_;

	my $new = {
		name =>    $attr->[0],
		version => $attr->[1],
		arch =>    $attr->[2],
		repo =>    $attr->[3],
		vendor =>  $attr->[4]
	};
	# old-version -> new-version
	$new->{version} =~ s/.*->\s*//;
	push(@$list, $new);
}

sub fetch_packages {
	my $interactive = shift;
	my @res;

	my @cmd = qw(zypper);
	push(@cmd, "--non-interactive") if !$interactive;
	push(@cmd, qw(-vv install --download-only));
	push(@cmd, @_);
	pipe(READ, WRITE);
	my $pid = fork();
	if (!$pid) {
		# child
		close(READ);
		open(STDOUT, ">&WRITE");
		if (!$interactive) {
			open(NULL, '<', "/dev/null");
			open(STDIN, "<&NULL");
			close(NULL);
			open(NULL, '>', "/dev/null");
			open(STDERR, ">&NULL");
			close(NULL);
		}
		exec(@cmd);
	}
	# parent
	close(WRITE);
	my ($len, $buf, $last_line);
	my ($state, @cur_pkg);
	$state = 0;
	$last_line = "";
	STDOUT->autoflush(1);
	while (($len = sysread(READ, $buf, 4096))) {
		print $buf if $interactive;
		next if $state == 2;
		my @lines = split(/\n/, $buf, -1);
		$lines[0] = $last_line . $lines[0];
		# XXX: Assumes that the very last line is terminated by \n
		$last_line = pop(@lines);
		for my $l (@lines) {
			if ($state == 0 && $l =~ /^The following.* package.* going to be (installed|upgraded):/) {
				$state = 1;
				next;
			}
			next unless $state == 1;
			if ($l eq "") {
				$state = 2;
				if (@cur_pkg) {
					add_package(\@res, \@cur_pkg);
				}
				next;
			}
			$l =~ s/ *$//;
			if ($l =~ /^[^ ]/) {
				if (@cur_pkg) {
					add_package(\@res, \@cur_pkg);
				}
				@cur_pkg = ($l);
			}
			if ($l =~ /^ /) {
				$l =~ s/^ *//;
				push(@cur_pkg, $l);
			}
		}
	}
	STDOUT->autoflush(0);
	close(READ);
	waitpid($pid, 0);
	my $ret = $?;
	return if $ret != 0;
	return @res;
}

my %repo_cache;
sub get_repo_cache {
	my $name = shift;
	my $res;

	if (exists($repo_cache{$name})) {
		return $repo_cache{$name};
	}
	open(my $pipe, '-|', "zypper", "repos", $name);
	while (<$pipe>) {
		chomp;
		if (m@^MD Cache Path\s*:\s*(/.*)@) {
			$res = $1;
			$res =~ s:/raw/:/packages/:;
			$res =~ s/\s*$//;
		}
	}
	close($pipe);
	$repo_cache{$name} = $res;
	return $res;
}

print "Fetching packages\n";
my @packages = fetch_packages(0, @ARGV);
if (!@packages) {
	print "zypper returned an error, retrying in interactive mode\n";
	@packages = fetch_packages(1, @ARGV);
}
if (!@packages) {
	exit 1;
}
my %local_packages;
for $a (@ARGV) {
	if ($a =~ /\.rpm$/ && -e $a) {
		open(my $pipe, '-|', "rpm", "-qp", "--qf",
			'%{n}-%{v}-%{r}.%{arch}', $a);
		my $nvra = <$pipe>;
		close($pipe);
		if (defined($nvra)) {
			$local_packages{$nvra} = $a;
		}
	}
}

for my $p (@packages) {
	my $nvra = "$p->{name}-$p->{version}.$p->{arch}";
	if ($p->{repo} eq "Plain RPM files cache") {
		if (exists($local_packages{$nvra})) {
			$p->{path} = $local_packages{$nvra};
		} else {
			print STDERR "Cannot find package $p->{name}\n";
		}
		next;
	}
	my $dir = get_repo_cache($p->{repo});
	if (!$dir) {
		print STDERR "Cannot find zypper cache for repository $p->{repo} (package $p->{name})\n";
		next;
	}
	my $file = "$nvra.rpm";
	my $wanted = sub {
		$p->{path} = $File::Find::name if $_ eq $file;
	};
	find($wanted, $dir);
	if (!$p->{path}) {
		print STDERR "Cannot find $file in zypper cache ($dir)\n";
		next;
	}
}
for my $p (@packages) {
	print "$p->{path}\n" if $p->{path};
}
